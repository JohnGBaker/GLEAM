fef0f20e9fb07d3673a9954dd784451c07121623
On branch master
Your branch is up-to-date with 'origin/master'.

Changes not staged for commit:
  (use "git add/rm <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

	modified:   Makefile
	modified:   ProbabilityDist/Makefile
	deleted:    bayesian.cc
	modified:   bayesian.hh
	modified:   chain.hh
	modified:   probability_function.hh
	modified:   proposal_distribution.hh
	modified:   sines.hh
	modified:   testMH
	modified:   testMH.cpp

Untracked files:
  (use "git add <file>..." to include in what will be committed)

	bayesian.cc.bk
	states.cc
	states.hh

no changes added to commit (use "git add" and/or "git commit -a")
diff --git a/Makefile b/Makefile
index 6b559b1..0f7f760 100644
--- a/Makefile
+++ b/Makefile
@@ -1,4 +1,9 @@
-MCMC_OFILES = bayesian.o chain.o probability_function.o proposal_distribution.o  ptmcmc.o
+MCMC_OFILES = states.o chain.o probability_function.o proposal_distribution.o  ptmcmc.o
+LIB ?= ${CURDIR}/lib
+INCLUDE ?= ${CURDIR}/include
+export LIB INCLUDE
+
+default:test
 
 test: testMH
 
@@ -8,16 +13,22 @@ DUMMY:
 #Make library if needed.
 ${LIB}:
 	mkdir ${LIB}
+${INCLUDE}:
+	mkdir ${INCLUDE}
 
 #Hacky way to handle subdirectories
-${LIB}/libprobdist.a: DUMMY ${LIB}
+${LIB}/libprobdist.a: ${LIB} ${INC}
+	@echo "LIB="${LIB}
+	@echo "INC="${INC}
 	@echo "Descending to ProbabilityDist"
 	@cd ProbabilityDist;${MAKE} ${MFLAGS}
 
-chain.o: chain.cc chain.hh bayesian.hh probability_function.hh proposal_distribution.hh
-proposal_distribution.o: proposal_distribution.cc bayesian.hh probability_function.hh proposal_distribution.hh
-probability_function.o: probability_function.cc bayesian.hh probability_function.hh
-ptmcmc.o: ptmcmc.cc bayesian.hh ptmcmc.hh chain.hh options.hh
+chain.o: chain.cc chain.hh states.hh probability_function.hh proposal_distribution.hh ${LIB}/libprobdist.a
+proposal_distribution.o: proposal_distribution.cc states.hh probability_function.hh proposal_distribution.hh ${LIB}/libprobdist.a
+probability_function.o: probability_function.cc states.hh probability_function.hh ${INCLUDE}/newran.h
+ptmcmc.o: ptmcmc.cc bayesian.hh states.hh ptmcmc.hh chain.hh options.hh probability_function.hh proposal_distribution.hh
+states.o: states.hh
+
 
 ${LIB}/libptmcmc.a: ${MCMC_OFILES}
 	@echo "archiving"
@@ -26,16 +37,17 @@ ${LIB}/libptmcmc.a: ${MCMC_OFILES}
 clean:
 	@echo "Cleaning ptMCMC"
 	rm -f *.o *.a 
+	rm -f ${LIB}/*.a
 	@cd ProbabilityDist;${MAKE} ${MFLAGS} clean;cd -
 
 docs:
 	doxygen dox.cfg
 
 testMH: testMH.cpp ${LIB}/libprobdist.a ${LIB}/libptmcmc.a
-	${CXX} $(CFLAGS) -o testMH -lprobdist -lptmcmc -L${LIB} $<
+	${CXX} $(CFLAGS) -std=c++11 -o testMH -lprobdist -lptmcmc -L${LIB} $<
 
 testPT: testPT.cpp ${LIB}/libprobdist.a ${LIB}/libptmcmc.a
-	${CXX} $(CFLAGS) -o testPT -lprobdist -lptmcmc -L${LIB} $<
+	${CXX} $(CFLAGS) -std=c++11 -o testPT -lprobdist -lptmcmc -L${LIB} $<
 
 .SUFFIXES: .c .cc .o
 
diff --git a/ProbabilityDist/Makefile b/ProbabilityDist/Makefile
index d3bfe2b..67fd6bb 100644
--- a/ProbabilityDist/Makefile
+++ b/ProbabilityDist/Makefile
@@ -5,10 +5,11 @@ all: ${LIB}/libprobdist.a  ${INCLUDE}/ProbabilityDist.h
 
 headers: ProbabilityDist.h
 
-${LIB}/libprobdist.a: ${PROBDIST_OFILES} ${NEWRAN_OFILES}
+${LIB}/libprobdist.a: ${PROBDIST_OFILES} ${NEWRAN_OFILES} ${INCLUDE}/ProbabilityDist.h
 	ar rv ${LIB}/libprobdist.a ${PROBDIST_OFILES} ${NEWRAN_OFILES}
 
 ${INCLUDE}/ProbabilityDist.h: ProbabilityDist.h include.h newran.h myexcept.h extreal.h simpstr.h
+	@echo "Installing headers in "${INCLUDE}
 	cp ProbabilityDist.h include.h newran.h myexcept.h extreal.h simpstr.h ${INCLUDE}/
 
 
diff --git a/bayesian.cc b/bayesian.cc
deleted file mode 100644
index b8a640b..0000000
--- a/bayesian.cc
+++ /dev/null
@@ -1,184 +0,0 @@
-///General structures for Bayesian analysis
-///
-///state objects are tied to a stateSpace object which specifies to domain.
-///boundary objects allow specification of the domain bounraies in each dimension.
-///John G Baker - NASA-GSFC (2013-2014)
-
-#include "bayesian.hh"
-
-bool boundary::enforce(double &x){
-    //cout<<"boundary::enforce: testing value "<<x<<" in range "<<show()<<endl;//debug
-    //check wrapping first
-    if(lowertype==wrap^uppertype==wrap){//can't have just one wrap 
-      cout<<"boundary::enforce: Inconsistent wrap."<<endl;
-      return false;
-    } else if (lowertype==wrap) {
-      //cout<<"boundary::enforce: testing value "<<x<<" in range "<<show()<<endl;//debug
-      double width=xmax-xmin;
-      if(width<=0){
-	cout<<"  boundary::enforce: Wrap: Negative width."<<endl;//debug
-	return false;
-      }
-      double xt=fmod(x-xmin,width);
-      if(xt<0)xt+=width;//fmod is stupid and finds the remainder after rounding *toward* zero.
-      x=xmin+xt;//Note label range is open near xmax, closed to xmin
-      //cout<<"  Wrap: OK."<<endl;//debug
-      return true;
-    } 
-    //next check reflection
-    if (lowertype==reflect&&uppertype==reflect){
-      //double reflection is like wrapping, then folding
-      double halfwidth=xmax-xmin;
-      if(halfwidth<=0){
-	return false;
-	cout<<"boundary::enforce:  DoubleReflect: Negative width."<<endl;//debug
-      }
-      double width=2*halfwidth;
-      double xt=fmod(x-xmin,width);
-      if(xt<0)xt+=width;
-      if(xt>=halfwidth)xt=halfwidth-xt;
-      x=xmin+xt;
-      cout<<"  DoubleReflect hasn't been tested...."<<endl;//debug
-      return true;
-    }
-    if(lowertype==reflect&&x<xmin)x=xmin+(xmin-x);
-    else if(uppertype==reflect&&x>xmax)x=xmax-(x-xmax);
-    if(lowertype==limit&&x<xmin){
-      //cout<<"  Lower limit failure."<<endl;//debug
-      return false;
-    }
-    if(uppertype==limit&&x<xmax){
-      //cout<<"  Upper limit failure."<<endl;//debug
-      return false;
-    };
-    //cout<<"  All good!."<<endl;//debug
-    return true;
-  };
-
-///Show structural info
-string boundary::show(){
-  ostringstream s;
-  if(lowertype==wrap)s<<"w["<<xmin<<","<<xmax<<")w";
-  else {
-    if(lowertype==reflect)s<<"R[";
-    else if(lowertype==limit)s<<"[";
-    else s<<"(";
-    s<<xmin<<","<<xmax;
-    if(uppertype==reflect)s<<"]R";
-    else if(uppertype==limit)s<<"]";
-    else s<<")";
-  }
-  return s.str();
-};
-
-/// State space class allows reference to overall limits and structure of the space.
-/// Can provide support for boundary conditions, maybe special flows that can be used in proposals...
-/// Should inner product be defined here?  probably...
-
-bool stateSpace::enforce(valarray<double> &params){
-    if(params.size()!=dim){
-      cout<<"stateSpace::enforce:  Dimension error.  Expected "<<dim<<" params, but given "<<params.size()<<"."<<endl;
-      exit(1);
-    }
-    for(uint i=0;i<dim;i++){
-      //cout<<"stateSpace::enforce: testing parameter "<<i<<endl;//debug
-      if(!bounds[i].enforce(params[i])){
-	//cout<<"        FAILED."<<endl;
-	return false;
-      }
-    }
-    //cout<<"        PASSED."<<endl;
-    return true;
-};
-
-///Show structural info
-string stateSpace::show(){
-    ostringstream s;
-    s<<"StateSpace:(dim="<<dim<<")\n";
-    for(uint i=0;i<dim;i++){
-      s<<"  "<<get_name(i)<<" in "<<bounds[i].show()<<"\n";
-    }
-    return s.str();
-};
-
-      
-void state::enforce(){
-  if(!space)valid=false;
-  if(!valid)return;
-  valid=space->enforce(params);
-  //cout<<"state::enforce:State was "<<(valid?"":"not ")<<"valid."<<endl;//debug
-};
-
-state::state(stateSpace *space,int n):space(space){
-  params.resize(n,0);
-  valid=false;
-  //cout<<"state::state():space="<<this->space<<endl;    
-  if(space){
-    valid=true;
-    enforce();
-  }
-};
-state::state(stateSpace *sp, const valarray<double>&array):space(sp),params(array){
-  //cout<<"state::state(stuff):space="<<this->space<<endl;
-  valid=false;
-  if(space)valid=true;
-  enforce();
-};
-  //some algorithms rely on using the states as a vector space
-state state::add(const state &other)const{
-    //here we only require that the result is valid.
-    state result(space,size());
-    if(other.size()!=size()){
-      cout<<"state::add: Sizes mismatch. ("<<size()<<"!="<<other.size()<<")\n";
-      exit(1);
-    }
-    for(uint i=0;i<size();i++)result.params[i]=params[i]+other.params[i];
-    result.enforce();
-    return result;
-  };
-
-state state::scalar_mult(double x)const{
-    //we only require that the result is valid
-    state result(space,size());
-    for(uint i=0;i<size();i++)result.params[i]=params[i]*x;
-    result.enforce();
-    return result;
-  };
-
-///For some applications it is necessary to have an inner product on the state space. Probably should move this out to stateSpace.
-double state::innerprod(state other)const{
-    if(!(valid&&other.valid))return NAN;
-    double result=0;
-    if(other.size()!=size()){
-      cout<<"state::innerprod: sizes mismatch.\n";
-      exit(1);
-    }
-    for(uint i=0;i<size();i++)result+=params[i]*other.params[i];
-    return result;
-};
-
-string state::get_string()const{
-    ostringstream s;
-    int n=params.size();
-    //cout<<"n="<<n<<endl;//debug
-    for(int i=0;i<n-1;i++){
-      //cout<<"i="<<i<<endl;
-      s<<params[i]<<", ";
-    }
-    if(n>0)s<<params[n-1];
-    else s<<"<empty>";
-    if(!valid)s<<" [INVALID]";
-    return s.str();
-};
-
-string state::show(){
-    ostringstream s;
-    s<<"(\n";
-    for(uint i=0;i<params.size();i++)s<<"  "<<(space?space->get_name(i):"[???]")<<" = "<<params[i]<<"\n";
-    s<<")\n";
-    return s.str();
-};
-
-
-
-
diff --git a/bayesian.hh b/bayesian.hh
index 5731ef4..2a47f36 100644
--- a/bayesian.hh
+++ b/bayesian.hh
@@ -1,148 +1,35 @@
 ///General structures for Bayesian analysis
 ///
-///state objects are tied to a stateSpace object which specifies to domain.
-///boundary objects allow specification of the domain bounraies in each dimension.
-///John G Baker - NASA-GSFC (2013-2015)
+///This is a set of interfaces for objects needed in Bayesian analysis.
+///The As of June2015, the interfaces are in early stages of development.
+///John G Baker - NASA-GSFC (2015)
 
 #ifndef PTMCMC_BAYESIAN_HH
 #define PTMCMC_BAYESIAN_HH
-#include <valarray>
-#include <vector>
-#include <sstream>
-#include <cmath>
-#include <iostream>
-//#include <utility>
-#include <memory>
-#include "ProbabilityDist.h"
-#include "newran.h"
+//#include <valarray>
+//#include <vector>
+//#include <sstream>
+//#include <cmath>
+//#include <iostream>
+//#include <memory>
+#include "probability_function.hh"
+#include "states.hh"
 #include "options.hh"
 
 using namespace std;
 
-typedef unsigned int uint;
-
-extern shared_ptr<Random>globalRNG;
-
-class probability_function;
-
-//********* BASE CLASSES *************
-/// A class for specifying 1-D boundary info. Used for stateSpace definition.
-class boundary {
-  int lowertype;
-  int uppertype;
-  double xmin;
-  double xmax;
-public:
-  static const int open=0;
-  static const int limit=1;
-  static const int reflect=2;
-  static const int wrap=3;
-  boundary(int lowertype=open,int uppertype=open,double min=-INFINITY,double max=INFINITY):lowertype(lowertype),uppertype(uppertype),xmin(min),xmax(max){};
-  ///enforce boundary condition. If consistent enforcement was achieved return true.
-  bool enforce(double &x);
-  ///Show structural info
-  string show();
-};
-
-/// State space class allows reference to overall limits and structure of the space.
-/// Can provide support for boundary conditions, maybe special flows that can be used in proposals...
-/// Should inner product be defined here?  probably...
-class stateSpace {
-  const int dim;
-  valarray<boundary> bounds;
-  valarray<string> names;
-  bool have_names;
-public:
-  stateSpace(int dim=0):dim(dim){
-    bounds.resize(dim,boundary());//default to default boundaries (ie allow all reals)
-    have_names=false;    
-  };
-  void set_bound(int i, const boundary &b){
-    if(i<dim)bounds[i]=b;
-    else{
-      cout<<"stateSpace::set_bound: Index out of range, "<<i<<">="<<dim<<"."<<endl;
-      exit(1);
-    }
-  };      
-  void set_names(string stringnames[]){
-    names.resize(dim,"");
-    for(uint i=0;i<dim;i++)names[i]=stringnames[i];
-    have_names=true;
-  };
-  string get_name(int i){
-    if(have_names&&i<dim)return names[i];
-    else return "[unnamed]";
-  };      
-  bool enforce(valarray<double> &params);
-  ///Show structural info
-  string show();
-};
-      
-///Class for holding and manipulating bayesian parameter states
-class state {
-  bool valid;
-  stateSpace *space;
-  valarray<double> params;
-  void enforce();
-public:
-  //Need assignment operator since default valarray assignment is problematic
-  const state& operator=(const state model){space=model.space;valid=model.valid,params.resize(model.size(),0);params=model.params;return *this;};
-  state(stateSpace *space=nullptr,int n=0);
-  state(stateSpace *sp, const valarray<double>&array);
-  int size()const{return params.size();}
-  //some algorithms rely on using the states as a vector space
-  virtual state add(const state &other)const;
-  virtual state scalar_mult(double x)const;
-  ///For some applications it is necessary to have an inner product on the state space. Probably should move this out to stateSpace.
-  virtual double innerprod(state other)const;
-  virtual string get_string()const;
-  virtual void get_params_array(valarray<double> &outarray)const{
-    //outarray.resize(params.size());
-    //for(size_t i=0;i<size();i++)outarray[i]=params[i];
-      outarray=std::move(params);
-    return;
-  }
-  virtual valarray<double> get_params()const{return params;};
-  virtual vector<double> get_params_vector(){vector<double> v;v.assign(begin(params),end(params));return v;};
-  stateSpace * getSpace(){return space;};
-  ///Show param info
-  string show();
-  bool invalid()const{return !valid;};
-};
-
-/// Base class for defining likelihoods/priors/etc (nonnormalized)
-/// Default version is flat.
-class probability_function {
-protected:
-  stateSpace *space;
+///Interface class for bayesian signal data. This is some kind of compound data.
+///We begin with only what we need for ptmcmc, that we can write the signal
+class bayes_signal {
 public:
-  virtual ~probability_function(){};
-  probability_function(stateSpace *space):space(space){};
-  virtual double evaluate(state &s){return exp(evaluate_log(s));};
-  virtual double evaluate_log(state &s){return 0;};
-  virtual string show(){return "UnspecifiedProb()";};
+  virtual int size()=0;
+  virtual void write(ostream &out,state &st, int nsamples=-1, double tstart=0, double tend=0)=0;
 };
 
-// A general (abstract) class for defining eg priors/etc 
-// from which we can draw samples.
-class sampleable_probability_function: public probability_function{
-  ///Sometimes we need to know the largest relevant dimension
-  void fail(){cout<<"sampleable_probability_function: This should be used strictly as a parent class, and it's virtual functions should be overridden in a base clas object.  Instances of this parent class should not be referenced."<<endl;exit(1);};
-protected:
-  unsigned int dim;
-public:
-  virtual ~sampleable_probability_function(){};
-  sampleable_probability_function(stateSpace *space):probability_function(space){};
-  virtual state drawSample(Random &rng){fail();return state();}
-  virtual double evaluate(state &s){fail();return -1;};
-  virtual double evaluate_log(state &s){fail();return -INFINITY;};
-  virtual int getDim(){return dim;};
-  virtual string show(){return "UnspecifiedSampleableProb()";};
-};
 
 ///Interface class for bayesian signal data. This is some kind of compound data.
 ///We begin with only what we need for ptmcmc, that we can write the signal
-class bayes_signal {
+class bayes_data_series {
 public:
   virtual int size()=0;
   virtual void write(ostream &out,state &st, int nsamples=-1, double tstart=0, double tend=0)=0;
@@ -172,5 +59,6 @@ public:
   virtual state bestState()=0;
 };
 
+
 #endif
 
diff --git a/chain.hh b/chain.hh
index fb8fb14..4f63eed 100644
--- a/chain.hh
+++ b/chain.hh
@@ -6,7 +6,8 @@
 #ifndef CHAIN_HH
 #define CHAIN_HH
 
-#include "bayesian.hh"
+#include "states.hh"
+#include "probability_function.hh"
 //#include "probability_function.hh"
 //#include <memory>
 //#include "include/ProbabilityDist.h"
@@ -266,9 +267,10 @@ class parallel_tempering_chains: public chain{
   bool evolve_temps(double rate=0.01){
     do_evolve_temps=1;
     evolve_temp_rate=rate;
+    return true;
   };
   void do_reboot(double rate,double threshhold,double thermal,int every,int grace=0,bool graduate=false,double aggression=0){max_reboot_rate=rate;reboot_thresh=threshhold;reboot_thermal_thresh=thermal;test_reboot_every=every;reboot_grace=grace;reboot_aggression=aggression;reboot_graduate=graduate;
     cout<<"Will reboot every "<<" aggression="<<reboot_aggression<<endl;
   };
-};  
+}; 
 #endif    
diff --git a/probability_function.hh b/probability_function.hh
index d55a58c..7362d94 100644
--- a/probability_function.hh
+++ b/probability_function.hh
@@ -6,20 +6,56 @@
 
 #ifndef PTMCMC_PROBABILITY_HH
 #define PTMCMC_PROBABILITY_HH
-#include "bayesian.hh"
+#include "states.hh"
 //#include <valarray>
 //#include <vector>
 //#include <sstream>
 //#include <cmath>
 //#include <iostream>
 //#include <utility>
-//#include <memory>
-//#include "include/ProbabilityDist.h"
-//#include "include/newran.h"
+#include <memory>
+#include "include/ProbabilityDist.h"
+#include "include/newran.h"
 
 using namespace std;
 
-typedef unsigned int uint;
+extern shared_ptr<Random>globalRNG;
+
+class probability_function;
+
+
+//** Base probability function classes
+
+/// Base class for defining likelihoods/priors/etc (nonnormalized)
+/// Default version is flat.
+class probability_function {
+protected:
+  stateSpace *space;
+public:
+  virtual ~probability_function(){};
+  probability_function(stateSpace *space):space(space){};
+  virtual double evaluate(state &s){return exp(evaluate_log(s));};
+  virtual double evaluate_log(state &s){return 0;};
+  virtual string show(){return "UnspecifiedProb()";};
+};
+
+// A general (abstract) class for defining eg priors/etc 
+// from which we can draw samples.
+class sampleable_probability_function: public probability_function{
+  ///Sometimes we need to know the largest relevant dimension
+  void fail(){cout<<"sampleable_probability_function: This should be used strictly as a parent class, and it's virtual functions should be overridden in a base clas object.  Instances of this parent class should not be referenced."<<endl;exit(1);};
+protected:
+  unsigned int dim;
+public:
+  virtual ~sampleable_probability_function(){};
+  sampleable_probability_function(stateSpace *space):probability_function(space){};
+  virtual state drawSample(Random &rng){fail();return state();}
+  virtual double evaluate(state &s){fail();return -1;};
+  virtual double evaluate_log(state &s){fail();return -INFINITY;};
+  virtual int getDim(){return dim;};
+  virtual string show(){return "UnspecifiedSampleableProb()";};
+};
+
 
 //********* DERIVED CLASSES *************
 
diff --git a/proposal_distribution.hh b/proposal_distribution.hh
index fd62035..c8d581d 100644
--- a/proposal_distribution.hh
+++ b/proposal_distribution.hh
@@ -6,7 +6,7 @@
 
 #ifndef PTMCMC_PROPOSAL_HH
 #define PTMCMC_PROPOSAL_HH
-#include "bayesian.hh"
+#include "states.hh"
 #include "chain.hh"
 #include "probability_function.hh"
 
@@ -144,7 +144,7 @@ public:
   state draw(state &s,chain *caller);
   virtual differential_evolution* clone()const{return new differential_evolution(*this);};
   string show();
-  bool support_mixing(bool do_it){do_support_mixing=do_it;};
+  bool support_mixing(bool do_it){do_support_mixing=do_it;return do_it;};
   bool support_mixing(){return do_support_mixing;};
 }; 
 #endif
diff --git a/sines.hh b/sines.hh
index 089b9c4..09a2b61 100644
--- a/sines.hh
+++ b/sines.hh
@@ -1,6 +1,6 @@
 #include <valarray>
 #include <cmath>
-#include "MCMC.hh"
+#include "probability_function.hh"
 
 ///Idea:
 /// For more vigorous testing.  It would be nice to have a model where the peaks do not all have the same shape,
@@ -63,6 +63,7 @@ class sines: public probability_function{
 // Prior implementing step levels that are flat, but differing discontinuously in the vicinity of each peak.
 // The prior implements the *same* manner of stair-step offseting as is provided in the sines class.
 // This allows experiments testing the effect of likelihood vs prior changes between peaks.
+/*
 class stepped_prior: public sampleable_probability_function{
   int Ndim,Npeaks;
   valarray<double> mins;
@@ -71,9 +72,9 @@ class stepped_prior: public sampleable_probability_function{
   double lognorm;
   valarray<double> cuts;
   valarray<valarray<int> > c_idxs;
-
+  
 public:
-  stepped_prior(stateSpace *space,valarray<int>&ks,valarray<double>&mins,valarray<double>&maxs,double stepscale=0):ks(ks),mins(mins),maxs(maxs),step_scale(stepscale),sampleable_probability_function(space){
+  stepped_prior(stateSpace *space,valarray<int>&ks,valarray<double>&mins,valarray<double>&maxs,double stepscale=0):mins(mins),maxs(maxs),step_scale(stepscale),sampleable_probability_function(space){
     Ndim=ks.size();
     compute_cuts();
   };
@@ -146,5 +147,6 @@ public:
     lognorm=log(sum);
     valarray<int> result(idxs,Ndim);
     return result;
+  };
 };
-
+*/
diff --git a/testMH b/testMH
index aa29ac8..0018fe3 100755
Binary files a/testMH and b/testMH differ
diff --git a/testMH.cpp b/testMH.cpp
index 8b53d1f..41a5273 100644
--- a/testMH.cpp
+++ b/testMH.cpp
@@ -1,13 +1,13 @@
 #include <valarray>
 #include <iostream>
 #include <fstream>
-#include "bayesian.hh"
+#include <string>
+#include <sstream>
+#include "states.hh"
 #include "chain.hh"
 #include "probability_function.hh"
 #include "proposal_distribution.hh"
 #include "sines.hh"
-#include <string>
-#include <sstream>
 
 using namespace std;
 
